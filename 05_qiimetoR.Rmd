---
output: html_document
editor_options: 
  chunk_output_type: console
---
# From Qiime2 into R - Initial diagnostics
  
In this chapter you will learn how to import Qiime2-produced ASV tables, taxonomy tables and tree files into R. For this exercise we will us publicly available FastQ files that were generated by a research group in Denmark. The files are available under accession number PRJNA645373.  
Reference: [1] C. Jiang, S.J. McIlroy, R. Qi, F. Petriglieri, E. Yashiro, Z. Kondrotaite, P.H. Nielsen, Identification of microorganisms responsible for foam formation in mesophilic anaerobic digesters treating surplus activated sludge, Water Res. 191 (2021) 116779. https://doi.org/10.1016/j.watres.2020.116779.  
  
Sample IDs  
You decide on the samplesIDs before you start your library prep and sequencing. In this dataset the sampleIDs are longer, e.g. "SRR12204258" and "SRR12204269", compared to the previous chapter, where the SampleIDs were short, e.g. "PT-01", "PT-02". It does not matter how you label each of your indexed samples as long as the IDs are unique.  And each unique ID in the `samplesheet.csv` needs to match the IDs of the `feature_table.qza`, which originate from the FastQ filenames and the Qiime import manifest before denoising with DADA2. If an ID does not match or if there is a different number of samples between these  two input files, then phyloseq will complain.  
!["First three ASV IDs and Sample IDs in this dataset](./img/ASVIDs.png)  
  
  
ASV IDs   
The same principle applies to each individual amplicon sequence in the ASV table and the taxonomy file. The ASVs IDs have to match between the `feature_table.qza` and the `taxonomy_silva.qza`.
!["First three ASV IDs (Feature ID) and related Taxon assignments in this dataset](./img/ASVIDs2.png) 
    \
    
NOTE: After the denoising, taxonomic classification and tree alignments in Qiime2, I prefer to do all subsequent analysis in R. However, it is also possible to do much of the diversity analysis in Qiime2. In fact, some  interesting plug-ins and functions in Qiime2 are not available as packages in R, hence for some specific tasks you may need to keep using Qiime2. It is up to the goals and preferences of the investigator.  
  
  \
  
**Required files**  
* samplesheet.tsv - same file that was used in the visualisation steps in Qiime2  
* feature_table.qza - if you created a phylogenetic tree from the sequences as described in the previous chapter then the ASVs in the feature table were filtered to match the ASVs in the tree. Hence the files was named featuretable-insertiontree-filtered.qza to differentiate it.    
* taxonomy_silva.qza  
* insertion-tree.qza  
  
  \
  
**Packages**  
  
First install the required packages. Some packages are stored on 'remote' repositories such as GitHub, hence before you can install them you need helper packages such as `remotes`. Other packages, such as phyloseq are managed by BioConductor project. They provide their own package manager package for R called BiocManager, which helps to install from the same release. Both, remotes and BiocManager are already installed in the below example.  
  
```{r packages, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# install.packages("remotes")
# if (!requireNamespace("BiocManager", quietly = TRUE))
#  install.packages("BiocManager")
# remotes::install_github("jbisanz/qiime2R")
# BiocManager::install("phyloseq")

library(qiime2R)  # to import qiime.qza into an R object
library(phyloseq) # To combine all relevant data objects into one object for easy data management
library(tidyverse) # Compilation of packages for data management 
library(stringr)  # to change some of the strings in taxonomic names in Silva 
library(vegan)   # A commonly used package in numerical ecological 

```
  
  \
  
**Import qiime-related files**
  
Now that packages are loaded we can import the Qiime2 `.qza` and the `.tsv` files. The aim is to import everything as R objects, which are then combined into one phyloseq object. Once we have a phyloseq object, any filtering and visualisations can be run from the one object.  
  
In the previous chapter, we used a `samplesheet.tsv` to visualise and summarise the `feature_table.qza`. That exact same samplesheet.tsv is imported here and slightly changed to make it phyloseq friendly. In this example, all relevant Qiime2 outputs were copied into a folder named 'qiimefiles'.   
  
  
```{r psobject, include=TRUE, echo=TRUE,warning=FALSE, message=FALSE}

# Sample sheet
metadata <- read_tsv("qiimefiles/samplesheet.tsv")  # lets call the R object 'metadata' to reflect its purpose 
# Inspect the metadata object. The second row is qiime-specific information and has to be removed. 

# Converting columns to numeric using "tidyverse"
metadata2 <- metadata[c(2:nrow(metadata)),] %>%     # remove the top row and convert characters to factors
  rownames_to_column("spl")%>% # this just adds the rownames to a column and calles in "spl"
  mutate_all(type.convert) %>%
  mutate_if(is.factor, as.character) %>%  # reformatting columns to avoid any problems with factors at this stage
  column_to_rownames("spl") %>%  # this puts the column "spl" back into rownames
  as_tibble() %>% 
  column_to_rownames("#SampleID")

# str(metadata2)  # use the `str` command to inspect the data


## Qiime import                      
SVs <-  qiime2R::read_qza("qiimefiles/featuretable-insertiontree-filtered.qza")
ASVtable <- SVs$data   # extract the data table


# Taxonomy
taxonomy <- qiime2R::read_qza("qiimefiles/taxonomy_silva.qza") # import the qiime object
taxonomy <- taxonomy$data  # extract the taxonomy data
## re-format the taxonomy file to split the taxonomy into columns
## remove the confidence column
taxtable <- taxonomy %>% as_tibble() %>%
  separate(Taxon, sep=";", c("Kingdom","Phylum","Class","Order","Family","Genus","Species"))  %>%
  dplyr::select(-Confidence) %>%
  column_to_rownames("Feature.ID") %>%
  as.matrix()


# Tree
tree <- read_qza("qiimefiles/insertion-tree.qza")
tree <- tree$data  #extract data


# Create the phyloseq object 
ps <-phyloseq(
  otu_table(ASVtable, taxa_are_rows = T), 
  sample_data(metadata2),
  phyloseq::tax_table(taxtable),
  phyloseq::phy_tree(tree)
)

# ps  (not run)

# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 4218 taxa and 51 samples ]
# sample_data() Sample Data:       [ 51 samples by 14 sample variables ]
# tax_table()   Taxonomy Table:    [ 4218 taxa by 7 taxonomic ranks ]
# phy_tree()    Phylogenetic Tree: [ 4218 tips and 4217 internal nodes ]


# remove things out of the R environment you dont need. 
rm(metadata, metadata2, SVs, taxonomy, taxtable, tree, ASVtable)


## Remove those annoying short codes in front of taxa names (i.e. p__ etc) as they
## dont look good in visualisation
tax_table(ps)[, "Kingdom"] <- str_replace_all(tax_table(ps)[, "Kingdom"], "d__", "")
tax_table(ps)[, "Phylum"] <- str_replace_all(tax_table(ps)[, "Phylum"], " p__", "")
tax_table(ps)[, "Class"] <- str_replace_all(tax_table(ps)[, "Class"], " c__", "")
tax_table(ps)[, "Order"] <- str_replace_all(tax_table(ps)[, "Order"], " o__", "")
tax_table(ps)[, "Family"] <- str_replace_all(tax_table(ps)[, "Family"], " f__", "")
tax_table(ps)[, "Genus"] <- str_replace_all(tax_table(ps)[, "Genus"], " g__", "")
tax_table(ps)[, "Species"] <- str_replace_all(tax_table(ps)[, "Species"], " s__", "")


```
From the output of the `ps` object we can see that there are 4281 ASVs in 51 samples and associated with 14 variables in the metadata.  
  
If you wish, you can access each individual data set from the ps object with functions `otu_table(ps)@.Data`, `sample_data(ps)` `tax_table(ps)@.Data` or `phy_tree(ps)`.  This can become handy if you want to change something, such as adding columns to the sample_data or changing them to a factor etc..  
  
```{r, psobject2, include=TRUE, echo=TRUE,warning=FALSE, message=FALSE}

ASVs <- otu_table(ps)@.Data
metadata <- sample_data(ps)
taxtable <- tax_table(ps)@.Data
tree <- phy_tree(ps)

# Inspect individual objects in your own time. 

```
  
  \
   
   
**Initial filtering**     
  
Keep the orginal `ps` object unchanged. Create new objects for subsequent filtering steps.   
  
Often we simply filter out any ASVs that have less than x number of reads and are present in less than x number of samples. This helps to reduce noise and the overload of zeros in the dataset, which some differential abundance tests can't deal with. Perhaps, it also helps with removing ASVs that were incorrectly denoised with DADA2 in the first place. However, it also means that rare ASVs with a low prevalence are not considered. So filtering has to be done with consideration to the intended analysis.  
   
Then filter out any phyla that came up as uncharacterized and taxa that came up as mitochondria and chloroplast.  
  
```{r filtering, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# filter as needed. This will be your final otu-table.
# Although you can still filter for specific analysis if needed.
# minimum of reads per feature
ps.flt = prune_taxa(taxa_sums(ps) >= 5, ps) #minimum reads per feature
ps.flt = filter_taxa(ps.flt, function(x) sum(x > 0) > (0.04*length(x)), TRUE) #minimum presence in x% of samples (51 * 0.04 = 2 samples)
 
# ps.flt (not run)
# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 1695 taxa and 51 samples ]
# sample_data() Sample Data:       [ 51 samples by 14 sample variables ]
# tax_table()   Taxonomy Table:    [ 1695 taxa by 7 taxonomic ranks ]
# phy_tree()    Phylogenetic Tree: [ 1695 tips and 1694 internal nodes ]


#filter any phyla that have not been classified i.e. contain nothing in the phylum column of the taxtable

ps.flt  = subset_taxa(ps.flt , !is.na(Phylum) & !Phylum %in% c(""))

# ps.flt (not run)
# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 1688 taxa and 51 samples ]
# sample_data() Sample Data:       [ 51 samples by 14 sample variables ]
# tax_table()   Taxonomy Table:    [ 1688 taxa by 7 taxonomic ranks ]
# phy_tree()    Phylogenetic Tree: [ 1688 tips and 1687 internal nodes ]
  

# Filter out non-bacteria, mitochondia and chloroplast taxa
ps.flt <- ps.flt %>%
  subset_taxa(Kingdom == "Bacteria" & Family  != "Mitochondria" & Class   != "Chloroplast"
 & !is.na(Phylum))

# ps.flt (not run)

# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 1674 taxa and 51 samples ]
# sample_data() Sample Data:       [ 51 samples by 14 sample variables ]
# tax_table()   Taxonomy Table:    [ 1674 taxa by 7 taxonomic ranks ]
# phy_tree()    Phylogenetic Tree: [ 1674 tips and 1673 internal nodes ]

```
  
  \
  
**Rarefaction curve**
  
Check if you cover enough depth for diversity analyses. Some samples may have low species richness, including a negative or samples that failed during PCR for example. The rarefaction curve will help assess which samples you may have to exclude from subsequent diversity calculations. It also provides a general view if most sample    
  
The curve shows you the number of 'Species' (i.e. ASVs) on the y axis and the total reads on the x axis for each sample.  
```{r rarefactions, include=TRUE, echo=TRUE,warning=FALSE, message=FALSE}
# filter
# `%notin%` = Negate(`%in%`)
# physeqB.flt.norefs <-  prune_samples(sample_data(physeqB.flt)$Treatment %notin% c("Heat", "H2O2"), physeqB.flt)

vegan::rarecurve(t(otu_table(ps.flt)), step=200, sample = min(colSums(otu_table(ps.flt))), label = FALSE, xlab = "Sample Size after filtering") 

# show the lowest number of reads.  
max(colSums(otu_table(ps.flt)))
min(colSums(otu_table(ps.flt)))
```


## Prevelance table
Create a prevalence table to see which phyla have low prevalence
```{r, include=TRUE, echo=TRUE,warning=FALSE, message=FALSE}
## Create a prevalence table to see which phyla have low prevalence
physeqB.flt.prevtab <-  prune_samples(sample_data(physeqB.flt)$Treatment != "Reference", physeqB.flt)
physeqB.flt.prevtab <-  prune_samples(sample_data(physeqB.flt.prevtab)$Treatment != "Blank", physeqB.flt.prevtab)
prevelancedf = apply(X = phyloseq::otu_table(physeqB.flt.prevtab),
                       MARGIN = 1,
                       FUN = function(x){sum(x > 0)})
prevelancedf = data.frame(Prevalence = prevelancedf,
                            TotalAbundance = taxa_sums(physeqB.flt.prevtab),
                            phyloseq::tax_table(physeqB.flt.prevtab))

prevelancedf <- plyr::ddply(prevelancedf, "Phylum", function(df1){
  data.frame(mean_prevalence=mean(df1$Prevalence), total_abundance=sum(df1$TotalAbundance,na.rm = T), stringsAsFactors = F)
  })
prevelancedf
```

**Note:**  
This code is an amalgamation from various sources. Apart from putting it together into a pipeline I do not take credit for it.
